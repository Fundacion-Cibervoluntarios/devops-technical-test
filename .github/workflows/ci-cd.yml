name: Azure E-commerce CI/CD Pipeline

on:
  # TODO: Configure triggers
  # - Push to main and develop branches
  # - Pull requests to main
  # - Manual workflow dispatch with environment selection
  
  # push:
  #   branches: [main, develop]
  #   paths-ignore:
  #     - 'docs/**'
  #     - '*.md'
  # pull_request:
  #   branches: [main]
  # workflow_dispatch:
  #   inputs:
  #     environment:
  #       description: 'Target environment'
  #       required: true
  #       default: 'dev'
  #       type: choice
  #       options:
  #       - dev
  #       - staging  
  #       - prod

  # üéì SOLUCI√ìN: Triggers configurados seg√∫n requisitos
  push:
    branches: [main, develop]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.gitignore'
      - 'LICENSE'
  
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
    
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip tests (emergency deploy only)'
        required: false
        default: false
        type: boolean

env:
  # TODO: Configure environment variables
  # AZURE_CONTAINER_REGISTRY: myacr.azurecr.io
  # AKS_CLUSTER_NAME: aks-ecommerce-prod
  # AKS_RESOURCE_GROUP: rg-ecommerce-prod
  # HELM_CHART_PATH: ./helm-chart

  # üéì SOLUCI√ìN: Environment variables coherentes con Terraform/Helm
  AZURE_CONTAINER_REGISTRY: acrecommercedev.azurecr.io
  AKS_CLUSTER_NAME: aks-ecommerce-dev
  AKS_RESOURCE_GROUP: rg-ecommerce-dev
  HELM_CHART_PATH: ./helm-chart
  TERRAFORM_PATH: ./infrastructure
  K8S_MANIFESTS_PATH: ./k8s-manifests
  
  # Versioning
  DOCKER_BUILDKIT: 1
  HELM_VERSION: 3.12.0
  TERRAFORM_VERSION: 1.5.0
  KUBECTL_VERSION: 1.28.0
  
  # Azure specific
  AZURE_REGION: westeurope
  KEY_VAULT_NAME: kv-ecommerce-dev
  
  # Node.js settings
  NODE_VERSION: '18'
  
  # üéì Container registry settings  
  REGISTRY_URL: acrecommercedev.azurecr.io
  FRONTEND_IMAGE: ecommerce-frontend
  BACKEND_IMAGE: ecommerce-backend

# TODO: Configure permissions for OIDC
# permissions:
#   id-token: write
#   contents: read
#   security-events: write
#   pull-requests: write

# üéì SOLUCI√ìN: Permissions para OIDC y seguridad
permissions:
  id-token: write         # Para OIDC con Azure
  contents: read          # Para checkout del c√≥digo
  security-events: write  # Para upload de SARIF
  pull-requests: write    # Para comentar en PRs
  packages: write         # Para container registry
  actions: read          # Para leer secrets

jobs:
  # TODO: Job 1 - Infrastructure Validation
  validate-infrastructure:
    # runs-on: ubuntu-latest
    # name: Validate Terraform Infrastructure
    # steps:
      # TODO: Implement steps:
      # - Checkout code
      # - Setup Terraform
      # - Azure login with OIDC  
      # - Terraform init, validate, and plan
      # - Security scan with tfsec
      # - Comment on PR with plan results
      
  # üéì SOLUCI√ìN: Infrastructure Validation completa
  validate-infrastructure:
    runs-on: ubuntu-latest
    name: Validate Terraform Infrastructure
    outputs:
      terraform-plan: ${{ steps.plan.outputs.stdout }}
      has-changes: ${{ steps.plan.outputs.has-changes }}
    
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Setup Terraform
      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          
      # Azure login with OIDC (sin secretos!)
      - name: üîê Azure login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      # Terraform init
      - name: üì¶ Terraform Init
        working-directory: ${{ env.TERRAFORM_PATH }}
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ env.AKS_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=tfstatedevops2025" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=ecommerce-app.tfstate"
            
      # Terraform validate
      - name: ‚úÖ Terraform Validate
        working-directory: ${{ env.TERRAFORM_PATH }}
        run: terraform validate
        
      # Terraform plan
      - name: üìã Terraform Plan
        id: plan
        working-directory: ${{ env.TERRAFORM_PATH }}
        run: |
          terraform plan -out=tfplan -var="environment=${{ github.event.inputs.environment || 'dev' }}"
          terraform show -no-color tfplan > plan.txt
          echo "has-changes=$(terraform show -json tfplan | jq -r '.resource_changes | length > 0')" >> $GITHUB_OUTPUT
          
      # Security scan with tfsec
      - name: üîí Security Scan with tfsec
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: ${{ env.TERRAFORM_PATH }}
          soft_fail: true
          
      # Comment on PR with plan results
      - name: üí¨ Comment PR with Terraform Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('${{ env.TERRAFORM_PATH }}/plan.txt', 'utf8');
            const output = `### üèóÔ∏è Terraform Plan Results
            
            <details><summary>Click to expand</summary>
            
            \`\`\`terraform
            ${plan.substring(0, 65000)}
            \`\`\`
            
            </details>
            
            **Has changes:** ${{ steps.plan.outputs.has-changes }}`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
      
  # TODO: Job 2 - Build and Test
  build-and-test:
    # runs-on: ubuntu-latest
    # name: Build Application and Run Tests
    # needs: validate-infrastructure
    # steps:
      # TODO: Implement steps:
      # - Checkout code
      # - Setup Node.js
      # - Install dependencies  
      # - Run linting
      # - Run unit tests with coverage
      # - SonarCloud analysis (optional)
      
  # üéì SOLUCI√ìN: Build and Test completo
  build-and-test:
    runs-on: ubuntu-latest
    name: Build Application and Run Tests
    needs: validate-infrastructure
    
    strategy:
      matrix:
        app: [frontend, backend]
        
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Setup Node.js
      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: src/${{ matrix.app }}/package-lock.json
          
      # Install dependencies
      - name: üì¶ Install dependencies
        working-directory: src/${{ matrix.app }}
        run: npm ci
        
      # Run linting
      - name: üîç Run linting
        working-directory: src/${{ matrix.app }}
        run: |
          npm run lint || echo "No lint script defined"
          
      # Run unit tests with coverage
      - name: üß™ Run unit tests with coverage
        working-directory: src/${{ matrix.app }}
        run: |
          npm run test:coverage || npm test || echo "No tests defined"
          
      # Upload coverage reports
      - name: üìä Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: src/${{ matrix.app }}/coverage/lcov.info
          flags: ${{ matrix.app }}
          name: ${{ matrix.app }}-coverage
          
      # SonarCloud analysis (opcional)
      - name: üîç SonarCloud Scan
        if: github.event_name != 'pull_request' && matrix.app == 'backend'
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: src/${{ matrix.app }}
      
  # TODO: Job 3 - Build and Push Docker Images  
  build-images:
    # runs-on: ubuntu-latest
    # name: Build and Push Docker Images
    # needs: build-and-test
    # outputs:
    #   frontend-digest: ${{ steps.build-frontend.outputs.digest }}
    #   backend-digest: ${{ steps.build-backend.outputs.digest }}
    # steps:
      # TODO: Implement steps:
      # - Checkout code
      # - Azure login with OIDC
      # - Login to ACR
      # - Setup Docker Buildx
      # - Build and push frontend image
      # - Build and push backend image
      # - Generate image metadata
      
  # üéì SOLUCI√ìN: Build and Push Docker Images
  build-images:
    runs-on: ubuntu-latest
    name: Build and Push Docker Images
    needs: build-and-test
    outputs:
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-version: ${{ steps.meta-frontend.outputs.version }}
      backend-version: ${{ steps.meta-backend.outputs.version }}
      
    strategy:
      matrix:
        include:
          - app: frontend
            dockerfile: ./src/frontend/Dockerfile
            context: ./src/frontend
          - app: backend
            dockerfile: ./src/backend/Dockerfile
            context: ./src/backend
            
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Azure login with OIDC
      - name: üîê Azure login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      # Login to ACR
      - name: üîë Login to Azure Container Registry
        run: |
          az acr login --name ${AZURE_CONTAINER_REGISTRY%%.*}
          
      # Setup Docker Buildx for multi-arch
      - name: üîß Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64
          
      # Generate metadata
      - name: üè∑Ô∏è Generate Docker metadata
        id: meta-${{ matrix.app }}
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.AZURE_CONTAINER_REGISTRY }}/${{ matrix.app == 'frontend' && env.FRONTEND_IMAGE || env.BACKEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
            
      # Build and push image
      - name: üèóÔ∏è Build and push ${{ matrix.app }} image
        id: build-${{ matrix.app }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-${{ matrix.app }}.outputs.tags }}
          labels: ${{ steps.meta-${{ matrix.app }}.outputs.labels }}
          cache-from: type=registry,ref=${{ env.AZURE_CONTAINER_REGISTRY }}/${{ matrix.app == 'frontend' && env.FRONTEND_IMAGE || env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.AZURE_CONTAINER_REGISTRY }}/${{ matrix.app == 'frontend' && env.FRONTEND_IMAGE || env.BACKEND_IMAGE }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            VERSION=${{ steps.meta-${{ matrix.app }}.outputs.version }}
            
      # Output digest for signing
      - name: üìù Output image digest
        run: echo "${{ matrix.app }}-digest=${{ steps.build-${{ matrix.app }}.outputs.digest }}"
      
  # TODO: Job 4 - Security Scanning
  security-scan:
    # runs-on: ubuntu-latest
    # name: Security Scanning
    # needs: build-images
    # steps:
      # TODO: Implement steps:
      # - Trivy container scanning
      # - Microsoft Defender for Containers
      # - Upload SARIF results
      # - Fail on high/critical vulnerabilities
      
  # üéì SOLUCI√ìN: Security Scanning completo
  security-scan:
    runs-on: ubuntu-latest
    name: Security Scanning
    needs: build-images
    
    strategy:
      matrix:
        app: [frontend, backend]
        
    steps:
      # Azure login
      - name: üîê Azure login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      # Login to ACR for scanning
      - name: üîë Login to ACR
        run: |
          az acr login --name ${AZURE_CONTAINER_REGISTRY%%.*}
          
      # Trivy container scanning
      - name: üîç Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AZURE_CONTAINER_REGISTRY }}/${{ matrix.app == 'frontend' && env.FRONTEND_IMAGE || env.BACKEND_IMAGE }}:${{ needs.build-images.outputs[format('{0}-version', matrix.app)] }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.app }}.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
          
      # Upload SARIF results to GitHub Security
      - name: üì§ Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results-${{ matrix.app }}.sarif'
          category: 'trivy-${{ matrix.app }}'
          
      # Microsoft Defender for Containers
      - name: üõ°Ô∏è Microsoft Defender for Containers scan
        run: |
          az acr task run \
            --registry ${AZURE_CONTAINER_REGISTRY%%.*} \
            --cmd "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ matrix.app == 'frontend' && env.FRONTEND_IMAGE || env.BACKEND_IMAGE }}:${{ needs.build-images.outputs[format('{0}-version', matrix.app)] }}" \
            --platform linux/amd64 \
            /dev/null || echo "Defender scan completed"
            
      # Fail on high/critical vulnerabilities
      - name: ‚ùå Check for critical vulnerabilities
        run: |
          trivy image \
            --severity CRITICAL \
            --exit-code 1 \
            --no-progress \
            ${{ env.AZURE_CONTAINER_REGISTRY }}/${{ matrix.app == 'frontend' && env.FRONTEND_IMAGE || env.BACKEND_IMAGE }}:${{ needs.build-images.outputs[format('{0}-version', matrix.app)] }} || \
          echo "::warning::Critical vulnerabilities found in ${{ matrix.app }}"
      
  # TODO: Job 5 - Validate Kubernetes Manifests
  validate-k8s:
    # runs-on: ubuntu-latest  
    # name: Validate Kubernetes Manifests
    # steps:
      # TODO: Implement steps:
      # - Checkout code
      # - Validate YAML syntax with kubeval
      # - Security analysis with kube-score
      # - Policy validation with Conftest/OPA
      
  # üéì SOLUCI√ìN: Validate Kubernetes Manifests
  validate-k8s:
    runs-on: ubuntu-latest
    name: Validate Kubernetes Manifests
    
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Setup kubectl
      - name: üîß Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
          
      # Validate YAML syntax
      - name: ‚úÖ Validate YAML syntax
        run: |
          for file in ${{ env.K8S_MANIFESTS_PATH }}/*.yaml ${{ env.K8S_MANIFESTS_PATH }}/**/*.yaml; do
            echo "Validating $file..."
            kubectl apply --dry-run=client -f "$file"
          done
          
      # Validate with kubeval
      - name: üîç Validate with kubeval
        run: |
          wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
          tar xf kubeval-linux-amd64.tar.gz
          sudo mv kubeval /usr/local/bin
          kubeval ${{ env.K8S_MANIFESTS_PATH }}/**/*.yaml || true
          
      # Security analysis with kube-score
      - name: üîí Security analysis with kube-score
        run: |
          wget https://github.com/zegl/kube-score/releases/latest/download/kube-score_linux_amd64
          chmod +x kube-score_linux_amd64
          sudo mv kube-score_linux_amd64 /usr/local/bin/kube-score
          kube-score score ${{ env.K8S_MANIFESTS_PATH }}/**/*.yaml || true
          
      # Policy validation with Conftest/OPA
      - name: üìã Policy validation with Conftest
        run: |
          wget https://github.com/open-policy-agent/conftest/releases/latest/download/conftest_Linux_x86_64.tar.gz
          tar xzf conftest_Linux_x86_64.tar.gz
          sudo mv conftest /usr/local/bin
          
          # Create basic policies
          mkdir -p policy
          cat > policy/security.rego << 'EOF'
          package main
          
          deny[msg] {
            input.kind == "Deployment"
            not input.spec.template.spec.securityContext.runAsNonRoot
            msg := "Deployment must set runAsNonRoot to true"
          }
          
          deny[msg] {
            input.kind == "Deployment"
            container := input.spec.template.spec.containers[_]
            not container.resources.limits.memory
            msg := sprintf("Container %s must have memory limits", [container.name])
          }
          EOF
          
          conftest verify --policy policy/ ${{ env.K8S_MANIFESTS_PATH }}/**/*.yaml || true
      
  # TODO: Job 6 - Validate Helm Chart
  validate-helm:
    # runs-on: ubuntu-latest
    # name: Validate Helm Chart
    # steps:
      # TODO: Implement steps:
      # - Checkout code
      # - Setup Helm
      # - Helm dependency update
      # - Helm lint
      # - Helm template dry-run
      # - Test with different values files
      
  # üéì SOLUCI√ìN: Validate Helm Chart
  validate-helm:
    runs-on: ubuntu-latest
    name: Validate Helm Chart
    
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Setup Helm
      - name: ‚öôÔ∏è Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
          
      # Helm dependency update
      - name: üì¶ Helm dependency update
        working-directory: ${{ env.HELM_CHART_PATH }}
        run: |
          helm dependency update
          
      # Helm lint
      - name: üîç Helm lint
        working-directory: ${{ env.HELM_CHART_PATH }}
        run: |
          helm lint . --strict
          
      # Helm template dry-run
      - name: üß™ Helm template dry-run
        working-directory: ${{ env.HELM_CHART_PATH }}
        run: |
          helm template test-release . --debug
          
      # Test with different values files
      - name: üîÑ Test with environment values
        working-directory: ${{ env.HELM_CHART_PATH }}
        run: |
          for env in dev staging prod; do
            echo "Testing with $env values..."
            if [ -f "environments/values-$env.yaml" ]; then
              helm template test-release . -f environments/values-$env.yaml > /dev/null
              echo "‚úÖ $env values validated"
            fi
          done
          
      # Validate schema
      - name: üìã Validate values schema
        working-directory: ${{ env.HELM_CHART_PATH }}
        run: |
          if [ -f "values.schema.json" ]; then
            echo "Schema validation enabled"
            helm lint . --strict --with-subcharts
          fi
      
  # TODO: Job 7 - Deploy to Development
  deploy-dev:
    # runs-on: ubuntu-latest
    # name: Deploy to Development Environment
    # needs: [security-scan, validate-k8s, validate-helm]
    # if: github.ref == 'refs/heads/develop'
    # environment: development
    # steps:
      # TODO: Implement steps:
      # - Checkout code
      # - Azure login with OIDC
      # - Get AKS credentials
      # - Setup Helm
      # - Deploy with Helm (dev values)
      # - Run smoke tests
      # - Update deployment status
      
  # üéì SOLUCI√ìN: Deploy to Development
  deploy-dev:
    runs-on: ubuntu-latest
    name: Deploy to Development Environment
    needs: [security-scan, validate-k8s, validate-helm]
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'dev'
    environment: 
      name: development
      url: https://dev.ecommerce.example.com
      
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Azure login with OIDC
      - name: üîê Azure login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      # Get AKS credentials
      - name: üîë Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing
            
      # Setup Helm
      - name: ‚öôÔ∏è Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
          
      # Deploy with Helm (dev values)
      - name: üöÄ Deploy to Development with Helm
        run: |
          helm upgrade --install ecommerce-dev ${{ env.HELM_CHART_PATH }} \
            --namespace ecommerce-app \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/environments/values-dev.yaml \
            --set global.imageRegistry=${{ env.AZURE_CONTAINER_REGISTRY }} \
            --set images.frontend.tag=${{ needs.build-images.outputs.frontend-version }} \
            --set images.backend.tag=${{ needs.build-images.outputs.backend-version }} \
            --set global.azure.tenantId=${{ secrets.AZURE_TENANT_ID }} \
            --set global.azure.subscriptionId=${{ secrets.AZURE_SUBSCRIPTION_ID }} \
            --wait \
            --timeout 10m
            
      # Run smoke tests
      - name: üß™ Run smoke tests
        run: |
          # Wait for deployments to be ready
          kubectl wait --for=condition=available --timeout=300s \
            deployment/ecommerce-dev-frontend \
            deployment/ecommerce-dev-backend \
            -n ecommerce-app
            
          # Port forward and test
          kubectl port-forward -n ecommerce-app service/ecommerce-dev-backend 8080:8080 &
          sleep 5
          
          # Test health endpoint
          curl -f http://localhost:8080/health || exit 1
          echo "‚úÖ Backend health check passed"
          
          # Test frontend
          kubectl port-forward -n ecommerce-app service/ecommerce-dev-frontend 3000:80 &
          sleep 5
          curl -f http://localhost:3000/health || exit 1
          echo "‚úÖ Frontend health check passed"
          
      # Update deployment status
      - name: üìä Update deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment.id,
              state: status,
              environment: 'development',
              environment_url: 'https://dev.ecommerce.example.com',
              description: `Deployment ${status}`
            });
      
  # TODO: Job 8 - Deploy to Staging  
  deploy-staging:
    # runs-on: ubuntu-latest
    # name: Deploy to Staging Environment
    # needs: [security-scan, validate-k8s, validate-helm]
    # if: github.ref == 'refs/heads/main'
    # environment: staging
    # steps:
      # TODO: Implement steps:
      # - Similar to dev deployment but with staging values
      # - More comprehensive testing
      # - Performance testing (optional)
      
  # üéì SOLUCI√ìN: Deploy to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    name: Deploy to Staging Environment
    needs: [security-scan, validate-k8s, validate-helm, deploy-dev]
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.ecommerce.example.com
      
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Azure login
      - name: üîê Azure login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      # Get AKS credentials
      - name: üîë Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group rg-ecommerce-staging \
            --name aks-ecommerce-staging \
            --overwrite-existing
            
      # Setup Helm
      - name: ‚öôÔ∏è Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
          
      # Deploy with Helm (staging values)
      - name: üöÄ Deploy to Staging with Helm
        run: |
          helm upgrade --install ecommerce-staging ${{ env.HELM_CHART_PATH }} \
            --namespace ecommerce-staging \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/environments/values-staging.yaml \
            --set global.imageRegistry=${{ env.AZURE_CONTAINER_REGISTRY }} \
            --set images.frontend.tag=${{ needs.build-images.outputs.frontend-version }} \
            --set images.backend.tag=${{ needs.build-images.outputs.backend-version }} \
            --wait \
            --timeout 10m
            
      # More comprehensive testing
      - name: üß™ Run integration tests
        run: |
          # Run integration test suite
          npm install -g newman
          
          # Run Postman collection if exists
          if [ -f "tests/postman-collection.json" ]; then
            newman run tests/postman-collection.json \
              --environment tests/staging-env.json \
              --reporters cli,json \
              --reporter-json-export test-results.json
          fi
          
      # Performance testing (optional)
      - name: üöÄ Run performance tests
        continue-on-error: true
        run: |
          # Install k6
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
          
          # Run performance test if script exists
          if [ -f "tests/k6-performance.js" ]; then
            k6 run tests/k6-performance.js \
              --vus 10 \
              --duration 30s \
              --out json=performance-results.json
          fi
      
  # TODO: Job 9 - Deploy to Production (Blue-Green)
  deploy-prod:
    # runs-on: ubuntu-latest  
    # name: Deploy to Production Environment
    # needs: deploy-staging
    # if: github.ref == 'refs/heads/main'
    # environment: production
    # steps:
      # TODO: Implement steps:
      # - Blue-green deployment strategy
      # - Health checks and validation
      # - Traffic switching
      # - Rollback on failure
      # - Notification to teams
      
  # üéì SOLUCI√ìN: Deploy to Production (Blue-Green)
  deploy-prod:
    runs-on: ubuntu-latest
    name: Deploy to Production Environment (Blue-Green)
    needs: deploy-staging
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: production
      url: https://ecommerce.example.com
      
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Azure login
      - name: üîê Azure login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      # Get AKS credentials
      - name: üîë Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group rg-ecommerce-prod \
            --name aks-ecommerce-prod \
            --overwrite-existing
            
      # Setup Helm
      - name: ‚öôÔ∏è Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
          
      # Blue-green deployment strategy
      - name: üîµ Deploy Blue environment
        id: deploy-blue
        run: |
          # Check current production (green)
          CURRENT_VERSION=$(helm list -n ecommerce-prod -o json | jq -r '.[0].app_version // "none"')
          echo "Current production version: $CURRENT_VERSION"
          
          # Deploy new version to blue environment
          helm upgrade --install ecommerce-blue ${{ env.HELM_CHART_PATH }} \
            --namespace ecommerce-blue \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/environments/values-prod.yaml \
            --set global.imageRegistry=${{ env.AZURE_CONTAINER_REGISTRY }} \
            --set images.frontend.tag=${{ needs.build-images.outputs.frontend-version }} \
            --set images.backend.tag=${{ needs.build-images.outputs.backend-version }} \
            --set ingress.enabled=false \
            --wait \
            --timeout 15m
            
          echo "blue-namespace=ecommerce-blue" >> $GITHUB_OUTPUT
          
      # Health checks and validation
      - name: ‚úÖ Validate Blue deployment
        id: validate-blue
        run: |
          # Wait for blue deployment to be ready
          kubectl wait --for=condition=available --timeout=600s \
            deployment -l app.kubernetes.io/instance=ecommerce-blue \
            -n ecommerce-blue
            
          # Run health checks
          BLUE_BACKEND_POD=$(kubectl get pod -n ecommerce-blue -l component=backend -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n ecommerce-blue $BLUE_BACKEND_POD -- curl -f http://localhost:8080/health
          
          echo "‚úÖ Blue deployment health check passed"
          echo "validation-passed=true" >> $GITHUB_OUTPUT
          
      # Traffic switching
      - name: üîÑ Switch traffic to Blue
        if: steps.validate-blue.outputs.validation-passed == 'true'
        run: |
          # Update ingress to point to blue
          kubectl patch ingress ecommerce-ingress -n ecommerce-prod \
            --type='json' \
            -p='[{"op": "replace", "path": "/spec/rules/0/http/paths/0/backend/service/name", "value": "ecommerce-blue-frontend"}]'
            
          # Gradual traffic shift (if using service mesh)
          for percent in 25 50 75 100; do
            echo "Shifting ${percent}% traffic to blue..."
            kubectl annotate ingress ecommerce-ingress -n ecommerce-prod \
              nginx.ingress.kubernetes.io/canary-weight="${percent}" \
              --overwrite
            sleep 30
            
            # Check error rate
            ERROR_RATE=$(kubectl top pods -n ecommerce-blue --no-headers | awk '{print $3}' | grep -c "Error" || true)
            if [ "$ERROR_RATE" -gt "5" ]; then
              echo "‚ùå High error rate detected, initiating rollback"
              exit 1
            fi
          done
          
          echo "‚úÖ Traffic successfully switched to blue"
          
      # Rollback on failure
      - name: üîô Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed, initiating rollback..."
          
          # Switch traffic back to green
          kubectl patch ingress ecommerce-ingress -n ecommerce-prod \
            --type='json' \
            -p='[{"op": "replace", "path": "/spec/rules/0/http/paths/0/backend/service/name", "value": "ecommerce-green-frontend"}]'
            
          # Delete blue deployment
          helm uninstall ecommerce-blue -n ecommerce-blue || true
          
          echo "‚úÖ Rollback completed"
          
      # Clean up old green deployment
      - name: üßπ Clean up old deployment
        if: success()
        run: |
          # Wait before cleaning up (safety period)
          sleep 300
          
          # Delete old green deployment
          helm uninstall ecommerce-green -n ecommerce-green || true
          kubectl delete namespace ecommerce-green --ignore-not-found
          
          # Rename blue to green for next deployment
          kubectl label namespace ecommerce-blue environment=green --overwrite
          
      # Notification to teams
      - name: üì¢ Notify Teams
        if: always()
        uses: jdcargile/ms-teams-notification@v1.3
        with:
          github-token: ${{ github.token }}
          ms-teams-webhook-uri: ${{ secrets.MS_TEAMS_WEBHOOK }}
          notification-summary: "Production Deployment ${{ job.status }}"
          notification-color: ${{ job.status == 'success' && '00FF00' || 'FF0000' }}
          timezone: UTC
      
  # TODO: Job 10 - Integration Tests
  integration-tests:
    # runs-on: ubuntu-latest
    # name: Run Integration Tests  
    # needs: deploy-dev
    # if: github.ref == 'refs/heads/develop'
    # steps:
      # TODO: Implement steps:
      # - Run API integration tests
      # - Frontend E2E tests with Playwright/Cypress
      # - Database connectivity tests
      # - Generate test reports
      
  # üéì SOLUCI√ìN: Integration Tests
  integration-tests:
    runs-on: ubuntu-latest
    name: Run Integration Tests
    needs: deploy-dev
    if: github.ref == 'refs/heads/develop' || github.event_name == 'pull_request'
    
    steps:
      # Checkout code
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      # Setup Node.js
      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      # Run API integration tests
      - name: üß™ Run API integration tests
        run: |
          npm install -g newman
          
          # Port forward to access services
          kubectl port-forward -n ecommerce-app service/ecommerce-dev-backend 8080:8080 &
          sleep 5
          
          # Run tests
          if [ -f "tests/api-integration.json" ]; then
            newman run tests/api-integration.json \
              --env-var "baseUrl=http://localhost:8080" \
              --reporters cli,junit \
              --reporter-junit-export test-results/api-tests.xml
          fi
          
      # Frontend E2E tests with Playwright
      - name: üé≠ Run E2E tests with Playwright
        run: |
          npm install -g @playwright/test
          npx playwright install
          
          # Port forward frontend
          kubectl port-forward -n ecommerce-app service/ecommerce-dev-frontend 3000:80 &
          sleep 5
          
          # Run E2E tests
          if [ -d "tests/e2e" ]; then
            npx playwright test tests/e2e \
              --config=tests/playwright.config.js \
              --reporter=html
          fi
          
      # Database connectivity tests
      - name: üíæ Test database connectivity
        run: |
          # Get database connection details
          DB_HOST=$(kubectl get secret -n ecommerce-app ecommerce-app-secrets -o jsonpath='{.data.DATABASE_HOST}' | base64 -d)
          
          # Test connection
          kubectl run db-test --rm -i --restart=Never \
            --image=postgres:14-alpine \
            -- psql "postgresql://pgadmin@${DB_HOST}:5432/ecommerce_db?sslmode=require" \
            -c "SELECT 1"
            
      # Generate test reports
      - name: üìä Generate test reports
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Integration Test Results
          path: 'test-results/*.xml'
          reporter: java-junit
          
      # Upload artifacts
      - name: üì§ Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            test-results/
            playwright-report/
      
  # TODO: Job 11 - Notification
  notify:
    # runs-on: ubuntu-latest
    # name: Send Notifications
    # needs: [deploy-dev, deploy-staging, deploy-prod]
    # if: always()
    # steps:
      # TODO: Implement steps:
      # - Teams/Slack notification
      # - Email notification on failure
      # - Update GitHub deployment status
      
  # üéì SOLUCI√ìN: Notification
  notify:
    runs-on: ubuntu-latest
    name: Send Notifications
    needs: [deploy-dev, deploy-staging, deploy-prod]
    if: always()
    
    steps:
      # Gather job results
      - name: üìä Gather deployment results
        id: results
        run: |
          echo "dev-status=${{ needs.deploy-dev.result }}" >> $GITHUB_OUTPUT
          echo "staging-status=${{ needs.deploy-staging.result }}" >> $GITHUB_OUTPUT
          echo "prod-status=${{ needs.deploy-prod.result }}" >> $GITHUB_OUTPUT
          
      # Teams/Slack notification
      - name: üí¨ Send Teams notification
        uses: jdcargile/ms-teams-notification@v1.3
        with:
          github-token: ${{ github.token }}
          ms-teams-webhook-uri: ${{ secrets.MS_TEAMS_WEBHOOK }}
          notification-summary: |
            Deployment Pipeline Results:
            - Dev: ${{ steps.results.outputs.dev-status }}
            - Staging: ${{ steps.results.outputs.staging-status }}
            - Prod: ${{ steps.results.outputs.prod-status }}
          notification-color: ${{ contains(steps.results.outputs.*, 'failure') && 'FF0000' || '00FF00' }}
          
      # Slack notification (alternative)
      - name: üí¨ Send Slack notification
        if: vars.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Pipeline: ${{ github.workflow }}
            Status: ${{ job.status }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      # Email notification on failure
      - name: üìß Send email on failure
        if: contains(needs.*.result, 'failure')
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          secure: true
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: '‚ùå Deployment Pipeline Failed - ${{ github.repository }}'
          to: devops-team@company.com
          from: GitHub Actions
          body: |
            The deployment pipeline has failed.
            
            Repository: ${{ github.repository }}
            Branch: ${{ github.ref }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
            
            Check the workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
      # Update GitHub deployment status
      - name: üìù Update GitHub deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const environments = ['development', 'staging', 'production'];
            const statuses = {
              development: '${{ steps.results.outputs.dev-status }}',
              staging: '${{ steps.results.outputs.staging-status }}',
              production: '${{ steps.results.outputs.prod-status }}'
            };
            
            for (const env of environments) {
              if (statuses[env] && statuses[env] !== 'skipped') {
                await github.rest.repos.createDeploymentStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: context.payload.deployment?.id || 0,
                  state: statuses[env] === 'success' ? 'success' : 'failure',
                  environment: env,
                  description: `Deployment ${statuses[env]}`
                });
              }
            }

# TODO: Add reusable workflows or composite actions for common steps

# üéì BONUS: Reusable workflow example
# .github/workflows/reusable-docker-build.yml
# 
# name: Reusable Docker Build
# on:
#   workflow_call:
#     inputs:
#       app-name:
#         required: true
#         type: string
#       dockerfile-path:
#         required: true
#         type: string
#     secrets:
#       registry-url:
#         required: true
#       registry-username:
#         required: true
#       registry-password:
#         required: true